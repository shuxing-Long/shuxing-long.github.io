<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>零的学习笔记</title>
    <link>https://shuxing-long.github.io/</link>
    <description>Recent content on 零的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 04 Jan 2022 21:48:05 +0800</lastBuildDate><atom:link href="https://shuxing-long.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating a New Theme</title>
      <link>https://shuxing-long.github.io/posts/2014/09/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://shuxing-long.github.io/posts/2014/09/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://shuxing-long.github.io/posts/2014/03/migrate-to-hugo-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://shuxing-long.github.io/posts/2014/03/migrate-to-hugo-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
    <item>
      <title>Feeling</title>
      <link>https://shuxing-long.github.io/blog/feeling/</link>
      <pubDate>Tue, 04 Jan 2022 21:48:05 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/blog/feeling/</guid>
      <description>点击下面查看笔记</description>
    </item>
    
    <item>
      <title>Feeling</title>
      <link>https://shuxing-long.github.io/feeling/20220104feeling/</link>
      <pubDate>Tue, 04 Jan 2022 21:48:05 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/feeling/20220104feeling/</guid>
      <description>为什么可以看手机到12点，却不可以看书到12点呢？ &amp;ndash;2022/01/04</description>
    </item>
    
    <item>
      <title>ProblemSolved</title>
      <link>https://shuxing-long.github.io/vue/problemsolved/</link>
      <pubDate>Fri, 02 Jul 2021 17:23:56 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/vue/problemsolved/</guid>
      <description>子组件向父组件传输数据 使用this.$emit(&amp;ldquo;父组件调用的函数&amp;rdquo;,传输的值)。 多值时this.$emit(&amp;ldquo;父组件调用的函数&amp;rdquo;,{传输的值1，传输的值2})。 例子： 子组件中：
 doExit(e){ e.preventDefault(); let _this=this; let isLogin=false; _this.$emit(&amp;quot;submit&amp;quot;,isLogin); //注销用户 } 父组件中：
 &amp;lt;projectList @submit=&amp;quot;doExit&amp;quot;&amp;gt;&amp;lt;/projectList&amp;gt; //对应的组件传递会走到@submit里的doExit函数里 methods: { doExit(result){ //注销用户 this.isLogin=result.isLogin; } }, </description>
    </item>
    
    <item>
      <title>Vue</title>
      <link>https://shuxing-long.github.io/blog/vue/</link>
      <pubDate>Fri, 02 Jul 2021 16:49:50 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/blog/vue/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mvc第五章</title>
      <link>https://shuxing-long.github.io/mvc/mvcfives/</link>
      <pubDate>Fri, 02 Jul 2021 16:03:04 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/mvc/mvcfives/</guid>
      <description>5.2 jQuery验证 $(function(){ $(&amp;quot;#registerFrm&amp;quot;).validate({ rules:{ uname:{ required:true }, upwd: { required:true }, upwd1:{ required:true, equalTo:&amp;quot;#upwd1&amp;quot; } },messages:{ uname:{ required:&amp;quot;请输入用户名！&amp;quot; }, upwd: { required: &amp;quot;请输入密码！&amp;quot; }, upwd1:{ required: &amp;quot;请输入确认密码！！&amp;quot;,equalTo:&amp;quot;两次密码输入的不一致！&amp;quot; } } }) }) 5.3 模型验证的写法 名称空间：System.ComponentModel.DataAnnotations
1 两个属性值必须相等：
 [Compare(&amp;quot;另一个判断的值&amp;quot;, ErrorMessage = &amp;quot;不能为空&amp;quot;) ] 2.其值必须在指定的数值范围内：
 [Range(10,20,ErrorMessage = &amp;quot;不能为空&amp;quot;)] 3.其值必须匹配正则表达式：
 [RegularExpression(&amp;quot;pattern&amp;quot;,ErrorMessage=&amp;quot;不能为空&amp;quot;)] 4.其值必须非空或不能只是空格：
 [Required(ErrorMessage(&amp;quot;不能为空&amp;quot;))] 5.其值长度不能超过给定的最大长度：
 [StringLength(10,ErrorMessage(&amp;quot;不能为空&amp;quot;))] </description>
    </item>
    
    <item>
      <title>MVC查缺补漏</title>
      <link>https://shuxing-long.github.io/mvc/mvccheckthegaps/</link>
      <pubDate>Fri, 02 Jul 2021 15:34:49 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/mvc/mvccheckthegaps/</guid>
      <description>记忆力不好,先记这里忘记了来这里看。方便 1.点击操作栏“删除”按钮，提示是否删除
 @Html.ActionLink(&amp;quot;删除&amp;quot;, &amp;quot;控制器名称&amp;quot;, new { id = item.PayerID },new { onclick=&amp;quot;return confirm(&#39;是否删除！&#39;)&amp;quot; }) </description>
    </item>
    
    <item>
      <title>C#查缺补漏</title>
      <link>https://shuxing-long.github.io/asp.net_web/checkthegaps/</link>
      <pubDate>Fri, 02 Jul 2021 14:26:35 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/asp.net_web/checkthegaps/</guid>
      <description>对C#的一些基础知识的查缺补漏，在此记录： 1.const是不变常量，在编译的时候就需要有确定的值，只能用于数值和字符串，或者引用类型只能为null.（这里为什么要把字符串单独拿出来？是因为字符串string是引用类型，但是使用的时候却感觉是值类型，它是一种特殊的引用类型，后面会详细说），struct也不能用const标记。const可以修饰class的字段或者局部变量，不能修饰属性。而readonly仅仅用于修饰class的字段，不能修饰属性。const是属于类级别而不是实例对象级别，不能跟static一起使用。而readonly既可以是类级别也可以是实例级别，它可以与static一起使用。
2.readonly是只读的意思，表示不能进行写操作。最重要的是它在程序运行时才会去求值。它可以是任意类型，当然可以是object，数组，struct，它必须在构造函数或者初始化器中初始化，初始化完成之后不能被修改。通常可以定义一个readonly值为DateTime的常量。而const却无法指定为DateTime类型。</description>
    </item>
    
    <item>
      <title>SQL理论</title>
      <link>https://shuxing-long.github.io/blog/sqltheory/</link>
      <pubDate>Thu, 03 Jun 2021 08:42:39 +0800</pubDate>
      
      <guid>https://shuxing-long.github.io/blog/sqltheory/</guid>
      <description>1.触发器的作业： 触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性， 可以跟踪数据库内的操作从而不允许未经可许的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表 的数据操作，而该操作又会导致该表触发器被触发。  2.什么是存储过程？用什么来调用： 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需建立一次，以后在该程序中就可以调用多次。 如果某次操作需要执行多次SQL,使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。  3.索引的作用？和它的优点和缺点： 索引就是一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询 整本书内容就可以找到想要的数据，索引可以是唯一的创建索引允许单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。  4.主键和索引的区别： (1).主键时为标识数据库记录的唯一性，不允许记录重复，且键值不能为空，主键也是一个特殊索引; (2).数据表中只允许有一个主键，但是可以有多个索引; (3).使用主键数据库会自动创建主索引，也可以在非主键上创建索引，方便查询效率; (4).索引可以提高查询速度，它就相当与在字典的目录，可以通过它很快查询到想要的结果，而不需要进行全表扫描; (5).主键也可以由多个字段组成，组成复合主键，同时主键肯定也是唯一索引; (6).唯一索引则标识该索引值唯一，可以由一个或几个字段组成，一个表可以有多个唯一索引;  5.什么是内存泄漏： 一般我们所说的内存泄漏指的是堆内存的泄漏。堆内存是程序从堆中为其分配的，大小任意的，使用完后要显示释放内存。当应用程序关键字new等创建对象时，就从堆中为它分配一块内存，使用完后程序调用free或者delete释放该内存，否则就说该内存就不能被使用，我们就说该内存被泄漏了。  6.维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么： 尽可能使用约束，如check,主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整性和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编写复杂，效率低下。  7.什么是事务： 事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个就被失败，以后操作就会回滚到操作状态，或者是上有一个 </description>
    </item>
    
  </channel>
</rss>
